<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
<meta property="og:type" content="website">
<meta property="og:title" content="ryansecreat blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="ryansecreat blog">
<meta property="og:description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ryansecreat">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ryansecreat blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ryansecreat blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">smile hard</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ryansecreat</p>
  <div class="site-description" itemprop="description">保持积极昂扬的状态，避免成为别人眼中的傻子</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/13/node/" class="post-title-link" itemprop="url">node</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-13 16:18:08 / 修改时间：17:48:53" itemprop="dateCreated datePublished" datetime="2020-08-13T16:18:08+08:00">2020-08-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>V8 浏览器会自动执行垃圾回收，但由于 JavaScript 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 V8 决定采用增量 标记算法回收：<br>即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。</li>
<li>Node 高消耗任务：1. Regex 2. 加密、压缩、fs 同步操作 3.json.stringfy</li>
<li>epoll是event poll的简写，是Linux内核提供的一种由事件驱动的I/O通知机制。</li>
<li>对第三方包和库做检测：NSP(Node Security Platform)</li>
<li>V8 机器码的体积要比字节码大的多，执行频率高的为热点代码，启动编译器进行编译，其它的解释器执行</li>
<li>Resovle 的任务进入微任务队列，暂停当前的协程，回到父协程</li>
<li>Npm ^ 限定minor 版本 ~限定patch 版本</li>
<li>Stream cork uncork</li>
<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>
<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>
<li><p>stream tranform</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class="line"></span><br><span class="line">const myTransform = new Transform(&#123;</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以引入corejs实现feature</p>
</li>
<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href="https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md" target="_blank" rel="noopener">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>
</li>
<li><p>一个promise类 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> </span>&#123;</span><br><span class="line">then(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>
</li>
<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>
<li>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。</li>
<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>
<li>Require.resovle() 获取模块的绝对路径  </li>
<li>peerDependencies 相关模块安装</li>
<li>websocket </li>
<li>cors 新浏览器<br>SameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.</li>
<li><p>主垃圾回收器：</p>
<p>主垃圾回收器主要负责老生区中的垃圾回收。</p>
<p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。</p>
<p>因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
</li>
<li><p>V8 中会把堆分为新生代和老生代两个区域，</p>
<p>新生代中存放的是生存时间短的对象，</p>
<p>老生代中存放的生存时间久的对象。</p>
<p>垃圾回收重要术语：</p>
<p>代际假说<br>大部分对象在内存中存在的时间很短<br>不死的对象，会活得更久<br>分代收集<br>副垃圾回收器：</p>
<p>主要负责新生代的垃圾回收。</p>
<p>这个区域不大，但是垃圾回收比较频繁。</p>
<p>新生代的垃圾回收算法是 Scavenge 算法。</p>
<p>主要把新生代空间对半划分为两个区域：对象区域，空闲区域。</p>
<p>当对象区域快被写满时，则会进行一次垃圾清理。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class="line"></span><br><span class="line">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class="line">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>
<ol>
<li>jwt 签名算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class="line">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class="line"></span><br><span class="line">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="egg"><a href="#egg" class="headerlink" title="egg"></a>egg</h3><ol>
<li>启动顺序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Master 启动后先 fork Agent 进程</span><br><span class="line">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class="line">Master 再 fork 多个 App Worker</span><br><span class="line">App Worker 初始化成功，通知 Master</span><br><span class="line">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/html/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/13/html/" class="post-title-link" itemprop="url">html</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-13 16:17:07" itemprop="dateCreated datePublished" datetime="2020-08-13T16:17:07+08:00">2020-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-08-18 18:28:48" itemprop="dateModified" datetime="2020-08-18T18:28:48+08:00">2020-08-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li></li>
<li><p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。</p>
</li>
<li><p>对HTML5有什么了解？</p>
<p>良好的移动性，以移动设备为主；<br>响应式设计，以适应自动变化的屏幕尺寸；<br>支持离线缓存技术，webStorage本地缓存；<br>新增了canvas，video，audio等新标签元素；以及特殊内容元素：article，footer，header，nav，section等；以及表单控件：calendar，date，time，email，url，search等；<br>新增webSocket/webWork技术；<br>还有新增的地理位置等。</p>
</li>
<li>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    </li>
<li><p>最新的HTML5标准中的API是什么</p>
<p>Canvas ：Canvas由HTML代码中定义的具有高度和宽度属性的可绘制区域组成。JavaScript代码可以通过一组完整的绘图函数访问该区域，这与其他常见的2D API类似，因此允许动态生成图形。Canvas 的一些预期用途包括构建图形、动画、游戏和图像合成。<br>媒体定时回放；<br>离线存储数据库；<br>文档编辑；<br>拖放；<br>跨文档消息传递；<br>浏览器历史管理；<br>MIME类型和协议处理程序注册；</p>
</li>
<li>对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中<br>对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧</li>
<li>HTML5文档类型：&lt;!doctype html&gt;    HTML5使用的编码 <meta charset="”UTF-8”"></li>
<li>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。</li>
<li>visibilitychange,可以用来判断浏览器页签是否显示。</li>
<li>WebP是一种新的图片格式，目标是减少文件大小但达到和JPEG格式相同的图片质量，能够减少网络上的请求时间。</li>
<li><p>DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CSS不会阻塞DOM解析，但会阻塞DOM渲染。</span><br><span class="line">CSS会阻塞JS执行，并不会阻塞JS文件下载</span><br><span class="line">``` </span><br><span class="line">1. `&lt;datalist&gt;`标签，用来定义选项列表，与input元素配合使用钙元素，来定义input可能的值。</span><br><span class="line">  datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</span><br><span class="line">  `&lt;input id=&quot;fruits&quot; list=&quot;fruit&quot; /&gt;&lt;datalist id=&quot;fruit&quot;&gt;  &lt;option value=&quot;apple&quot;&gt;  &lt;option value=&quot;orange&quot;&gt;  &lt;option value=&quot;banana&quot;&gt;&lt;/datalist&gt;`</span><br><span class="line">1. 首屏加载时间</span><br><span class="line">    performance.timing.domContentLoadedEventStart-performance.timing.navigationStart</span><br><span class="line">2.  preload 是声明式的 fetch，可以强制浏览器请求资源，同时不阻塞文档 onload 事件。Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。</span><br><span class="line">3. 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</span><br><span class="line">4. aside  定义页面的侧边栏内容。</span><br><span class="line">   progress 原生的进度条</span><br><span class="line"></span><br><span class="line">5.  HTML `&lt;sup&gt;` 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。</span><br><span class="line">6. domPropsInnerHTML  domPropsInnerText</span><br><span class="line">7. 根据 canvas 可以获取浏览器指纹信息</span><br><span class="line">```text</span><br><span class="line"></span><br><span class="line">绘制 canvas，获取 base64 的 dataurl</span><br><span class="line">对 dataurl 这个字符串进行 md5 摘要计算，得到指纹信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性</p>
</li>
<li><p>事件传播有三个阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class="line">目标阶段–事件已达到目标元素。</span><br><span class="line">冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>
</li>
<li><p>将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了</p>
</li>
<li>浏览器 Context Group 是一组共享相同上下文的 tab、window或iframe。例如，如果网站（<a href="https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过" target="_blank" rel="noopener">https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过</a> DOM API相互访问，例如 window.opener。</li>
<li>影响dom解析以及渲染都会出现白屏的问题</li>
<li>V8 内存空间越大，执行时间越长，为了性能，限制了</li>
<li><p>1.当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>
<p>2.当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>
</li>
<li>Host 支持虚拟站点</li>
<li></li>
<li>如果有js 在header 中，js会等待css 加载完毕。</li>
<li>Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。</li>
<li>重绘 只是影响元素的外观和风格，不影响布局的  回流：元素的布局、隐藏等改变需要重新构建</li>
<li>data-为前端开发者提供自定义属性，这些属性集可以通过对象的dataset属性获取，</li>
<li>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。</li>
<li>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。</li>
<li>Web quality  : alt</li>
<li><p>该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onstorage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'The '</span> + e.key + <span class="string">' key has been changed from '</span> + e.oldValue + <span class="string">' to '</span> + e.newValue + <span class="string">'.'</span>); &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。</p>
</li>
<li><p>preload：  直接请求<br>prefetch： 空闲时间请求</p>
</li>
<li><p>&lt;link rel=”dns-prefetch” href=”//baidu.com”&gt;<br>比较小的图片例如icon，使用base64编码，可以减少一次图片的网络请求；</p>
</li>
<li>cache control<br><code>`</code>text<br>private：客户端可以缓存–打开新的窗口会重新访问、地址栏回车时第一次访问、后退不访问<br>public：客户端和代理服务器都可以缓存<br>max-age=t：缓存内容将在t秒后失效<br>no-cache：需要使用协商缓存来验证缓存数据<br>no-store：所有内容都不会缓存</li>
</ol>
<p><code>`</code>   </p>
<ol>
<li><p>我们可以使用 requestIdleCallback() 在浏览器空闲时运行高耗时、低优先级的任务。</p>
</li>
<li><p>由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
</li>
<li>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</li>
<li><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
</li>
<li><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</p>
</li>
<li>dom树构建完成后document对象会派发事件DOMContentLoaded来通知dom树已构建完成。<br>DOMContentLoaded事件用来标识dom树构建完成，那如何判断另外这些非阻塞型的资源加载完成呢？答案是window.onload。由于该事件派发的过晚，因此一般情况下我们用不着，而更多的是用DOMContentLoaded来尽早的的操作dom。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/13/js/" class="post-title-link" itemprop="url">js</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-13 15:17:58" itemprop="dateCreated datePublished" datetime="2020-08-13T15:17:58+08:00">2020-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-08-24 10:03:41" itemprop="dateModified" datetime="2020-08-24T10:03:41+08:00">2020-08-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>管道符放到尾部：Hello(?:World|China|) 可以匹配 HelloWorld、HelloChina，也可以只匹配 Hello。<blockquote>
<p>console.log(‘子君’ instanceof String)  </p>
</blockquote>
</li>
<li><p>prototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   function f() &#123;&#125;</span><br><span class="line">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class="line">a === b    </span><br><span class="line">解析：a是构造函数f的原型 ： &#123;constructor: ƒ&#125;</span><br><span class="line">b是实例f的原型对象 ： ƒ () &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack hmr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.当修改了一个或多个文件；</span><br><span class="line">2.文件系统接收更改并通知webpack；</span><br><span class="line">3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；</span><br><span class="line">4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；</span><br><span class="line">5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git submodule </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule &apos;assets&apos; (https://github.com/maonx/vimwiki-assets.git) registered for path &apos;assets&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/maonx/vimwiki-assets.git assets</span><br><span class="line"></span><br><span class="line">$ git submodule update —remote</span><br></pre></td></tr></table></figure>
<ol>
<li>所以函数防抖适用的场景：监听窗口的滚动，缩放。高频发生的一些事件；函数节流适用的场景：涉及与后端交互的按钮，由于网络原因或者其他原因，导致接口没有返回值，用户一直点点点的问题。 </li>
<li>最优子结构、边界、动态转移方程。动态规划的核心—》从低向上，从而不会像递归那样保留调用栈。</li>
<li><p>十进制转为 2 进制，除 2 取余，然后余数反向</p>
<p>十进制转为 2 进制小时，<strong>乘 2 取整</strong></p>
</li>
<li><p>in操作符:检测指定对象(右边)原型链上是否有对应的属性值。<br> hasOwnProperty方法:检测指定对象自身上是否有对应的属性值。两者的区别在于in会查找原型链,而hasOwnProperty不会。</p>
<p>for…in…遍历对象上除了Symbol以外的可枚举属性,包括原型链上的属性。</p>
<p>Object.keys &amp; Object.assign &amp; JSON.stringify: excluding non-enumerable &amp; <strong>proto</strong></p>
</li>
<li><p>堆<br>堆的底层实际上是一棵完全二叉树，可以用数组实现<br>每个的节点元素值不小于其子节点 - 最大堆<br>每个的节点元素值不大于其子节点 - 最小堆</p>
</li>
<li><p>浏览器中 customevent</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">"cat"</span>, &#123;  <span class="attr">detail</span>: &#123;    <span class="attr">hazcheeseburger</span>: <span class="literal">true</span>  &#125;&#125;);obj.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<ol>
<li>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</li>
<li>Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。</li>
<li>regex  y stick 粘连修饰符 </li>
</ol>
<p>1.普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。</p>
<p>   当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当这一切都被恢复如初之时，就好像程序从原本暂停的地方继续向前执行了。</p>
<pre><code>而因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。
</code></pre><ol>
<li>Array(10)  稀疏矩阵</li>
<li><p>clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function initData(target) &#123;</span><br><span class="line">  return new target.constructor()</span><br><span class="line">&#125;</span><br><span class="line">return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class="line"></span><br><span class="line">function cloneReg(targe) &#123;</span><br><span class="line">    const reFlags = /\w*$/;</span><br><span class="line">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex = targe.lastIndex;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line">1. js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</span><br><span class="line">   </span><br><span class="line">   000：对象</span><br><span class="line">   010：浮点数</span><br><span class="line">   100：字符串</span><br><span class="line">   110：布尔</span><br><span class="line">   1：整数</span><br><span class="line">   </span><br><span class="line">   but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。</span><br><span class="line">   </span><br><span class="line">   null：所有机器码均为0</span><br><span class="line">   </span><br><span class="line">   undefined：用 −2^30 整数来表示</span><br><span class="line"></span><br><span class="line">1. console 分组</span><br><span class="line">```javascript</span><br><span class="line">console.group(&apos;action&apos;, &apos;A&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;%c prev state&apos;, &quot;color: #dddddd&quot;, &apos;\n&apos;, &#123;</span><br><span class="line">    name: &apos;a&apos;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;%c next state&apos;, &quot;color: #dddddd&quot;, &apos;\n&apos;,  &#123;</span><br><span class="line">    name: &apos;b&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.groupCollapsed();</span><br><span class="line">console.log(&apos;我是group折叠内容&apos;);</span><br><span class="line">console.groupEnd();</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.create(null) 和 {}</p>
</li>
<li><p>每次JavaScript对DOM的操作都会改变当前页面的呈现，并重新刷新整个页面，从而消耗了大量的时间。而createDocumentFragment()的作用，就是可以创建一个文档碎片，<br>把所有的新节点附加其上，然后把文档碎片的内容一次性添加到document中。</p>
</li>
<li><p>indexedDB 的特点：存储空间大：存储空间可以达到几百兆甚至更多；</p>
<pre><code>&gt;&gt; 支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；
&gt;&gt; IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；
&gt;&gt; 支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；
&gt;&gt; 键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
&gt;&gt; 数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。
</code></pre></li>
<li>Usecapture:<br>true - 事件句柄在捕获阶段执行。事件捕获从父到子。<br>false- false- 默认。事件句柄在冒泡阶段执行</li>
<li>浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. document.addEventListener(‘visibilitychange’)</li>
<li>Object.assign 继承的否Object.keys &amp; Object.assign &amp; JSON.stringify: excluding non-enumerable &amp; <strong>proto</strong></li>
<li>let is not global while var is.</li>
<li><p>download</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span> (<span class="params">url, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  a.download = name</span><br><span class="line">  a.rel = <span class="string">'noopener'</span></span><br><span class="line">  a.href = url</span><br><span class="line">  <span class="comment">// 触发模拟点击</span></span><br><span class="line">  a.dispatchEvent(<span class="keyword">new</span> MouseEvent(<span class="string">'click'</span>))</span><br><span class="line">  <span class="comment">// 或者 a.click()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一：Text -&gt; DataURL</span></span><br><span class="line"><span class="keyword">const</span> dataUrl = <span class="string">`data:,<span class="subst">$&#123;str&#125;</span>`</span></span><br><span class="line">download(dataUrl, <span class="string">'demo.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二：Text -&gt; Blob -&gt; ObjectURL</span></span><br><span class="line"><span class="keyword">const</span> url = URL.createObjectURL(<span class="keyword">new</span> Blob(str.split(<span class="string">''</span>)))</span><br><span class="line">download(url, <span class="string">'demo1.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">1. stringfy 格式化</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span>,</span><br><span class="line">  c: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str = <span class="built_in">JSON</span>.stringify(json, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. proxy </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">const</span> negativeArray = <span class="function"><span class="params">els</span> =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Proxy</span>(els, &#123;</span><br><span class="line">        <span class="keyword">get</span>: (target, propKey, receiver) =&gt;</span><br><span class="line">            Reflect.<span class="keyword">get</span>(</span><br><span class="line">                target,</span><br><span class="line">                +propKey &lt; 0 ? String(target.length + +propKey) : propKey,</span><br><span class="line">                receiver</span><br><span class="line">            )</span><br><span class="line">    &#125;);</span><br><span class="line">const unicorn = negativeArray(["京", "程", "一", "灯"]);</span><br><span class="line">unicorn[-1]; </span><br><span class="line">``` </span><br><span class="line">  </span><br><span class="line">1.  对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</span><br><span class="line">1. Es6-&gt;babel paser-&gt;babel traverse-&gt;babel core</span><br><span class="line">1.  类数组向数组转换 Array.from slice 。 aguments 就是arrarylike   </span><br><span class="line">1.  xhr  </span><br><span class="line">```js</span><br><span class="line"> </span><br><span class="line">var request = new XMLHttpRequest()</span><br><span class="line"> request.open('GET', 'index/a/b/c?name=TianTian', true);</span><br><span class="line"> request.onreadystatechange = function () &#123;</span><br><span class="line">   <span class="keyword">if</span>(request.readyState === <span class="number">4</span> &amp;&amp; request.status === <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">   &#125;&#125;;</span><br><span class="line"> request.send();</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string">1. V8 对重复的js代码有优化 即时编译技术，如果发现一段代码经常使用，则不用转字节码 直接执行机器码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 随机字符串 Math.random().toString(36).substr(2));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</span></span><br><span class="line"><span class="string">1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages</span></span><br><span class="line"><span class="string">1. npx babel-upgrade</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">3. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">4. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">5. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</span></span><br><span class="line"><span class="string">6. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</span></span><br><span class="line"><span class="string">7. js value</span></span><br><span class="line"><span class="string">8. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存</span></span><br><span class="line"><span class="string">9.  基本的数据类型 </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>text</span><br><span class="line">基本的数据类型</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">string</span><br><span class="line">boolean</span><br><span class="line">number</span><br><span class="line">symbol(ES6)</span><br></pre></td></tr></table></figure>
</li>
<li><p>navigator.userAgent: 返回当前浏览器的user agent字符串</p>
</li>
<li><p>懒加载：<br>Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。<br>能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。</p>
</li>
<li><p>Same origin 可以使用broadcast channel 两页面间通信。</p>
</li>
<li>注意闭包内this的指向</li>
<li>对于instanceof,无法判断基本类型，但可以正确判断引用类型</li>
<li>let x = 2_3333_3333 </li>
<li><p>哪些操作会造成内存泄漏？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.意外的全局变量</span><br><span class="line">2.被遗忘的计时器或回调函数</span><br><span class="line">3.脱离 DOM 的引用</span><br><span class="line">4.闭包</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map 对象中的数据是根据用户set 的顺序排序的，object 先排数字开头的。</p>
</li>
</ol>
<h3 id="dataStructure"><a href="#dataStructure" class="headerlink" title="dataStructure"></a>dataStructure</h3><ol>
<li>BST 查询二叉树<br>若任意节点的左⼦子树不不空，则左⼦子树上所有结点的值均⼩小于它的 根结点的值;<br>若任意节点的右⼦子树不不空，则右⼦子树上所有结点的值均⼤大于它的 根结点的值;<br>任意节点的左、右⼦子树也分别为⼆二叉查找树。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/fresh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/04/fresh/" class="post-title-link" itemprop="url">fresh</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-04 10:33:26" itemprop="dateCreated datePublished" datetime="2020-06-04T10:33:26+08:00">2020-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-09-23 20:54:36" itemprop="dateModified" datetime="2020-09-23T20:54:36+08:00">2020-09-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>① 不能通过 new 关键字调用, 没有原型<br>② 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响<br>③ 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments<br>④ 不支持重复命名参数<br>⑤ 隐式返回</li>
<li>v-once v-pre</li>
<li><p>readystate  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 是HTTP请求的状态，当一个XMLHttpRequest初次创建时，这个属性的值从0开始，直到接收到完整的HTTP响应，这个值增加到4</span><br><span class="line"> </span><br><span class="line">4：（完成）数据接收完毕，此时可以通过responseXml和responseText获取完整的回应数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>babel-register 则提供了动态编译。换句话说，我们的源代码能够真正运行在生产环境下，不需要 babel 编译这一环节。坏处是动态编译，导致程序在速度、性能上有所损耗。（ npx babel-node app.js） babel-node</p>
</li>
<li><p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p>
</li>
<li>Ztext.js 3d化文本支持中文</li>
<li><p>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line">mediatype 是个 MIME 类型的字符串，例如 &quot;image/jpeg&quot; 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII</span><br><span class="line"></span><br><span class="line">如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入。</span><br><span class="line"></span><br><span class="line">下面是一些示例：</span><br><span class="line"></span><br><span class="line">data:,Hello%2C%20World!</span><br><span class="line">简单的 text/plain 类型数据</span><br><span class="line">data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</span><br><span class="line">上一条示例的 base64 编码版本</span><br><span class="line">data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</span><br><span class="line">一个HTML文档源代码 &lt;h1&gt;Hello, World&lt;/h1&gt;</span><br><span class="line">data:text/html,&lt;script&gt;alert(&apos;hi&apos;);&lt;/script&gt;</span><br><span class="line">一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Url-loader 是将资源转换为base64</p>
</li>
<li><p>浏览器进程 1. 插件 2. 网络 3.Gpu 4.浏览器 5.渲染进程 浏览器为每个tab创建一个渲染进程，运行在沙箱模式下。包括 gui 线程等。</p>
</li>
<li><p>jest.spyOn()方法同样创建一个mock函数，但是该mock函数不仅能够捕获函数的调用情况，还可以正常的执行被spy的函数。实际上，jest.spyOn()是jest.fn()的语法糖，它创建了一个和被spy的函数具有相同内部代码的mock函数。</p>
</li>
<li><p>Vue Test Utils 允许你通过 shallowMount 方法只挂载一个组件而不渲染其子组件 (即保留它们的存根)：</p>
</li>
</ol>
<ol start="12">
<li>而对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点 vnode 的 data 中保留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，<br>只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。</li>
</ol>
<ol>
<li><p>红黑树<br>其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.节点是红色或黑色。</span><br><span class="line"></span><br><span class="line">2.根节点是黑色。</span><br><span class="line"></span><br><span class="line">3.每个叶子节点都是黑色的空节点（NIL节点）。</span><br><span class="line"></span><br><span class="line">4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</span><br><span class="line"></span><br><span class="line">5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。<br>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/stringencode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/10/stringencode/" class="post-title-link" itemprop="url">stringencode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-10 17:10:23" itemprop="dateCreated datePublished" datetime="2019-12-10T17:10:23+08:00">2019-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-29 14:22:24" itemprop="dateModified" datetime="2020-06-29T14:22:24+08:00">2020-06-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ASCII、UTF-8\16<br>unicode GB2312 </p>
<p>字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。</p>
<p>可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)</p>
<p>字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -&gt; 97、b -&gt; 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。</p>
<p>除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。</p>
<p>缺点：过于庞大、</p>
<p>中文的utf-8 大于GBk的两个字节</p>
<p>因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:</p>
<table>
<thead>
<tr>
<th>Unicode 编码(16进制)</th>
<th>utf-8 码位(二进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>000000-00007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>000080-0007FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>000800-00FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>010000-1FFFFF</td>
<td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td>
</tr>
</tbody>
</table>
<ol>
<li>escape</li>
<li>encodeURIComponent encodeURI</li>
</ol>
<p>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<br>使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。</p>
<p>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。<br>而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；<br>encodeURI 是W3C 的标准，而 Escape 是非标准。</p>
<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/security-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/09/security-1/" class="post-title-link" itemprop="url">security</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-09 18:11:18" itemprop="dateCreated datePublished" datetime="2019-12-09T18:11:18+08:00">2019-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-29 14:22:24" itemprop="dateModified" datetime="2020-06-29T14:22:24+08:00">2020-06-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>
<ol>
<li>反射型 XSS </li>
</ol>
<p>一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br>不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p>
<p>非持久型 XSS 漏洞攻击有以下几点特征：</p>
<p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。<br>攻击者需要诱骗点击,必须要通过用户点击链接才能发起<br>反馈率低，所以较难发现和响应修复<br>盗取用户敏感保密信息</p>
<ol start="2">
<li>存储型 XSS</li>
</ol>
<p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<p>持久型 XSS 有以下几个特点：</p>
<p>持久性，植入在数据库中<br>盗取用户敏感私密信息<br>危害面广</p>
<p>3.DOM xss</p>
<p>它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。</p>
<p>4.jsonp 服务端做处理</p>
<p>防御措施：1. httponly 2. csp 3.转义字符—现在的后端模板引擎都实现了转义 </p>
<p>增加攻击难度，降低攻击后果</p>
<p><a href="https://xss-game.appspot.com/level1" target="_blank" rel="noopener">https://xss-game.appspot.com/level1</a></p>
<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>
<h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p>CSRF的特点<br>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。<br>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。<br>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。<br>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>
<p>针对已上特点：同源检测 </p>
<ol>
<li>同源检测 </li>
</ol>
<p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>
<ul>
<li>Origin Header</li>
<li>Referer Header<br>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域</li>
</ul>
<p>但是Origin在以下两种情况下并不存在：</p>
<ul>
<li>IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions</li>
</ul>
<ul>
<li>302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li>
</ul>
<h4 id="使用Referer-Header确定来源域名"><a href="#使用Referer-Header确定来源域名" class="headerlink" title="使用Referer Header确定来源域名"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>
<p>通过refer 检测，可以定义不同的refer policy<br>攻击者可以在自己的请求中隐藏Referer。<br>CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>
<p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p>
<h4 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h4><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>
<p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p>
<p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p>
<h4 id="双重Cookie验证"><a href="#双重Cookie验证" class="headerlink" title="双重Cookie验证"></a>双重Cookie验证</h4><p>利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p>
<p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p>
<p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p>
<ol>
<li>用双重Cookie防御CSRF的优点：</li>
</ol>
<p>无需使用Session，适用面更广，易于实施。<br>Token储存于客户端中，不会给服务器带来压力。<br>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</p>
<ol start="2">
<li>缺点：</li>
</ol>
<p>无法使用httponly，这样造成了cookie的安全风险。<br>难以做到子域名的隔离。<br>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</p>
<p>Samesite Cookie属性</p>
<p>####Samesite Cookie属性</p>
<p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p>
<p>Samesite=Strict<br>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p>
<p>Samesite=Lax 打开链接或者页面跳转时可带Cookie</p>
<ol>
<li>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</li>
<li>SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</li>
</ol>
<ol>
<li>点击劫持</li>
<li>url 跳转漏洞(url 钓鱼)</li>
<li>图片钓鱼</li>
<li>iframe 钓鱼</li>
<li>os 命令注入</li>
</ol>
<p>strict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP</p>
<ol>
<li>post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发</li>
</ol>
<p>利用的form 表单、URL 跳转</p>
<p>waf:</p>
<ol>
<li>Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。</li>
<li>CC攻击防护：帮助您防护针对页面请求的CC攻击。</li>
<li>恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。</li>
<li>地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。</li>
</ol>
<ol>
<li>XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/08/encoding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/08/encoding/" class="post-title-link" itemprop="url">encoding</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-08 14:11:43" itemprop="dateCreated datePublished" datetime="2019-11-08T14:11:43+08:00">2019-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-29 14:22:24" itemprop="dateModified" datetime="2020-06-29T14:22:24+08:00">2020-06-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。</li>
<li>Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 ‘\r\n’ ，之后是分块本身，后面也是’\r\n’ 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。</li>
<li>ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。</li>
<li><p>utf-8  Refer:<a href="https://segmentfault.com/a/1190000014324711" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014324711</a></p>
<pre><code class="text">0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.
110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元

1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元
</code></pre>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/graphql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/23/graphql/" class="post-title-link" itemprop="url">graphql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-23 16:19:28" itemprop="dateCreated datePublished" datetime="2019-08-23T16:19:28+08:00">2019-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-29 14:22:24" itemprop="dateModified" datetime="2020-06-29T14:22:24+08:00">2020-06-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function(parent, args, ctx, info) &#123;</span><br><span class="line">    …</span><br><span class="line">其中的参数的意义如下：</span><br><span class="line"></span><br><span class="line">parent: 当前上一个Resolver的返回值</span><br><span class="line">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class="line">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class="line">info: 当前Query的AST对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>query（查询）：当获取数据时，应当选取Query类型</p>
<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>
<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/02/linux/" class="post-title-link" itemprop="url">linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-02 11:39:34" itemprop="dateCreated datePublished" datetime="2019-07-02T11:39:34+08:00">2019-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-22 21:08:52" itemprop="dateModified" datetime="2021-12-22T21:08:52+08:00">2021-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><ol>
<li><p>Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。</p>
</li>
<li><p>which 指令会在环境变量\$PATH 设置的目录里查找符合条件的文件。</p>
</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</span><br><span class="line">三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</span><br><span class="line">四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</span><br><span class="line">七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</span><br></pre></td></tr></table></figure>
<ol>
<li>本地盘 NVMe：相较于本地盘 SSD，提供更高的IOPS, 目前只支持大规格的实例类型。SSD 云盘：相较于本地盘，更灵活的存储空间，并且支持数据加密，更安全。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/es8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ryansecreat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ryansecreat blog">
      <meta itemprop="description" content="保持积极昂扬的状态，避免成为别人眼中的傻子">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ryansecreat blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/02/es8/" class="post-title-link" itemprop="url">es8</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-02 11:37:11" itemprop="dateCreated datePublished" datetime="2019-07-02T11:37:11+08:00">2019-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-29 14:22:24" itemprop="dateModified" datetime="2020-06-29T14:22:24+08:00">2020-06-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>
</li>
<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>
</li>
<li><p>Template Literals</p>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ryansecreat</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
